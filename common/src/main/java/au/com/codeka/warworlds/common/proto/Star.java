// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: star.proto at 30:1
package au.com.codeka.warworlds.common.proto;

import com.squareup.wire.FieldEncoding;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoAdapter;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.ProtoWriter;
import com.squareup.wire.WireEnum;
import com.squareup.wire.WireField;
import com.squareup.wire.internal.Internal;
import java.io.IOException;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.util.List;
import okio.ByteString;

/**
 *
 * Represents a single star within a sector. The star can have a few planets, though this
 * is optional (we don't always return the list of planets with a star).
 */
public final class Star extends Message<Star, Star.Builder> {
  public static final ProtoAdapter<Star> ADAPTER = new ProtoAdapter_Star();

  private static final long serialVersionUID = 0L;

  public static final String DEFAULT_KEY = "";

  public static final Long DEFAULT_SECTOR_X = 0L;

  public static final Long DEFAULT_SECTOR_Y = 0L;

  public static final String DEFAULT_NAME = "";

  public static final CLASSIFICATION DEFAULT_CLASSIFICATION = CLASSIFICATION.BLUE;

  public static final Integer DEFAULT_SIZE = 0;

  public static final Integer DEFAULT_OFFSET_X = 0;

  public static final Integer DEFAULT_OFFSET_Y = 0;

  public static final Long DEFAULT_TIME_EMPTIED = 0L;

  public static final Long DEFAULT_LAST_SIMULATION = 0L;

  /**
   * the identifier of the star, unique throughout the universe.
   */
  @WireField(
      tag = 1,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String key;

  /**
   * the sector this star is contained within
   */
  @WireField(
      tag = 11,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long sector_x;

  @WireField(
      tag = 12,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long sector_y;

  /**
   * the name of the star
   */
  @WireField(
      tag = 2,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String name;

  @WireField(
      tag = 3,
      adapter = "au.com.codeka.warworlds.common.proto.Star$CLASSIFICATION#ADAPTER"
  )
  public final CLASSIFICATION classification;

  /**
   * the apparent "size" of the star (which is really just a display thing)
   */
  @WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#INT32"
  )
  public final Integer size;

  /**
   * the offset from the left edge of the sector, in pixels
   */
  @WireField(
      tag = 6,
      adapter = "com.squareup.wire.ProtoAdapter#INT32"
  )
  public final Integer offset_x;

  /**
   * the offset from the bottom edge of the sector, in pixels
   */
  @WireField(
      tag = 7,
      adapter = "com.squareup.wire.ProtoAdapter#INT32"
  )
  public final Integer offset_y;

  /**
   * the collection of planets orbiting this star (may be empty, for example in the list
   * of stars in a sector)
   */
  @WireField(
      tag = 9,
      adapter = "au.com.codeka.warworlds.common.proto.Planet#ADAPTER",
      label = WireField.Label.REPEATED
  )
  public final List<Planet> planets;

  /**
   * collection of colonies on our planet(s)
   *  repeated Colony colonies = 10;
   * collection of buildings in our colonies.
   *  repeated Building buildings = 13;
   * collection of EmpirePresences details the presences of the empire(s) in this solar system.
   *  repeated EmpirePresence empires = 14;
   * collection of BuildRequests for colonies in this star
   *  repeated BuildRequest build_requests = 15;
   * List of fleets located in this star
   *  repeated Fleet fleets = 16;
   * This is the time (in seconds since Unix epoch) since this star "became" empty -- that is,
   * after the colony was destroyed. This only has meaning if the star has no colonies currently.
   */
  @WireField(
      tag = 17,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long time_emptied;

  /**
   * Time, that this star was last simulated
   */
  @WireField(
      tag = 18,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long last_simulation;

  @WireField(
      tag = 20,
      adapter = "au.com.codeka.warworlds.common.proto.Star$Wormhole#ADAPTER"
  )
  public final Wormhole wormhole;

  public Star(String key, Long sector_x, Long sector_y, String name, CLASSIFICATION classification, Integer size, Integer offset_x, Integer offset_y, List<Planet> planets, Long time_emptied, Long last_simulation, Wormhole wormhole) {
    this(key, sector_x, sector_y, name, classification, size, offset_x, offset_y, planets, time_emptied, last_simulation, wormhole, ByteString.EMPTY);
  }

  public Star(String key, Long sector_x, Long sector_y, String name, CLASSIFICATION classification, Integer size, Integer offset_x, Integer offset_y, List<Planet> planets, Long time_emptied, Long last_simulation, Wormhole wormhole, ByteString unknownFields) {
    super(ADAPTER, unknownFields);
    this.key = key;
    this.sector_x = sector_x;
    this.sector_y = sector_y;
    this.name = name;
    this.classification = classification;
    this.size = size;
    this.offset_x = offset_x;
    this.offset_y = offset_y;
    this.planets = Internal.immutableCopyOf("planets", planets);
    this.time_emptied = time_emptied;
    this.last_simulation = last_simulation;
    this.wormhole = wormhole;
  }

  @Override
  public Builder newBuilder() {
    Builder builder = new Builder();
    builder.key = key;
    builder.sector_x = sector_x;
    builder.sector_y = sector_y;
    builder.name = name;
    builder.classification = classification;
    builder.size = size;
    builder.offset_x = offset_x;
    builder.offset_y = offset_y;
    builder.planets = Internal.copyOf("planets", planets);
    builder.time_emptied = time_emptied;
    builder.last_simulation = last_simulation;
    builder.wormhole = wormhole;
    builder.addUnknownFields(unknownFields());
    return builder;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof Star)) return false;
    Star o = (Star) other;
    return Internal.equals(unknownFields(), o.unknownFields())
        && Internal.equals(key, o.key)
        && Internal.equals(sector_x, o.sector_x)
        && Internal.equals(sector_y, o.sector_y)
        && Internal.equals(name, o.name)
        && Internal.equals(classification, o.classification)
        && Internal.equals(size, o.size)
        && Internal.equals(offset_x, o.offset_x)
        && Internal.equals(offset_y, o.offset_y)
        && Internal.equals(planets, o.planets)
        && Internal.equals(time_emptied, o.time_emptied)
        && Internal.equals(last_simulation, o.last_simulation)
        && Internal.equals(wormhole, o.wormhole);
  }

  @Override
  public int hashCode() {
    int result = super.hashCode;
    if (result == 0) {
      result = unknownFields().hashCode();
      result = result * 37 + (key != null ? key.hashCode() : 0);
      result = result * 37 + (sector_x != null ? sector_x.hashCode() : 0);
      result = result * 37 + (sector_y != null ? sector_y.hashCode() : 0);
      result = result * 37 + (name != null ? name.hashCode() : 0);
      result = result * 37 + (classification != null ? classification.hashCode() : 0);
      result = result * 37 + (size != null ? size.hashCode() : 0);
      result = result * 37 + (offset_x != null ? offset_x.hashCode() : 0);
      result = result * 37 + (offset_y != null ? offset_y.hashCode() : 0);
      result = result * 37 + (planets != null ? planets.hashCode() : 1);
      result = result * 37 + (time_emptied != null ? time_emptied.hashCode() : 0);
      result = result * 37 + (last_simulation != null ? last_simulation.hashCode() : 0);
      result = result * 37 + (wormhole != null ? wormhole.hashCode() : 0);
      super.hashCode = result;
    }
    return result;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    if (key != null) builder.append(", key=").append(key);
    if (sector_x != null) builder.append(", sector_x=").append(sector_x);
    if (sector_y != null) builder.append(", sector_y=").append(sector_y);
    if (name != null) builder.append(", name=").append(name);
    if (classification != null) builder.append(", classification=").append(classification);
    if (size != null) builder.append(", size=").append(size);
    if (offset_x != null) builder.append(", offset_x=").append(offset_x);
    if (offset_y != null) builder.append(", offset_y=").append(offset_y);
    if (planets != null) builder.append(", planets=").append(planets);
    if (time_emptied != null) builder.append(", time_emptied=").append(time_emptied);
    if (last_simulation != null) builder.append(", last_simulation=").append(last_simulation);
    if (wormhole != null) builder.append(", wormhole=").append(wormhole);
    return builder.replace(0, 2, "Star{").append('}').toString();
  }

  public static final class Builder extends Message.Builder<Star, Builder> {
    public String key;

    public Long sector_x;

    public Long sector_y;

    public String name;

    public CLASSIFICATION classification;

    public Integer size;

    public Integer offset_x;

    public Integer offset_y;

    public List<Planet> planets;

    public Long time_emptied;

    public Long last_simulation;

    public Wormhole wormhole;

    public Builder() {
      planets = Internal.newMutableList();
    }

    /**
     * the identifier of the star, unique throughout the universe.
     */
    public Builder key(String key) {
      this.key = key;
      return this;
    }

    /**
     * the sector this star is contained within
     */
    public Builder sector_x(Long sector_x) {
      this.sector_x = sector_x;
      return this;
    }

    public Builder sector_y(Long sector_y) {
      this.sector_y = sector_y;
      return this;
    }

    /**
     * the name of the star
     */
    public Builder name(String name) {
      this.name = name;
      return this;
    }

    public Builder classification(CLASSIFICATION classification) {
      this.classification = classification;
      return this;
    }

    /**
     * the apparent "size" of the star (which is really just a display thing)
     */
    public Builder size(Integer size) {
      this.size = size;
      return this;
    }

    /**
     * the offset from the left edge of the sector, in pixels
     */
    public Builder offset_x(Integer offset_x) {
      this.offset_x = offset_x;
      return this;
    }

    /**
     * the offset from the bottom edge of the sector, in pixels
     */
    public Builder offset_y(Integer offset_y) {
      this.offset_y = offset_y;
      return this;
    }

    /**
     * the collection of planets orbiting this star (may be empty, for example in the list
     * of stars in a sector)
     */
    public Builder planets(List<Planet> planets) {
      Internal.checkElementsNotNull(planets);
      this.planets = planets;
      return this;
    }

    /**
     * collection of colonies on our planet(s)
     *  repeated Colony colonies = 10;
     * collection of buildings in our colonies.
     *  repeated Building buildings = 13;
     * collection of EmpirePresences details the presences of the empire(s) in this solar system.
     *  repeated EmpirePresence empires = 14;
     * collection of BuildRequests for colonies in this star
     *  repeated BuildRequest build_requests = 15;
     * List of fleets located in this star
     *  repeated Fleet fleets = 16;
     * This is the time (in seconds since Unix epoch) since this star "became" empty -- that is,
     * after the colony was destroyed. This only has meaning if the star has no colonies currently.
     */
    public Builder time_emptied(Long time_emptied) {
      this.time_emptied = time_emptied;
      return this;
    }

    /**
     * Time, that this star was last simulated
     */
    public Builder last_simulation(Long last_simulation) {
      this.last_simulation = last_simulation;
      return this;
    }

    public Builder wormhole(Wormhole wormhole) {
      this.wormhole = wormhole;
      return this;
    }

    @Override
    public Star build() {
      return new Star(key, sector_x, sector_y, name, classification, size, offset_x, offset_y, planets, time_emptied, last_simulation, wormhole, buildUnknownFields());
    }
  }

  /**
   * the classification of this star. The order of these enum values
   * must correspond to the order of the StarTypes defined in sector.py
   */
  public enum CLASSIFICATION implements WireEnum {
    BLUE(0),

    WHITE(1),

    YELLOW(2),

    ORANGE(3),

    RED(4),

    NEUTRON(5),

    BLACKHOLE(6),

    MARKER(7),

    WORMHOLE(8);

    public static final ProtoAdapter<CLASSIFICATION> ADAPTER = ProtoAdapter.newEnumAdapter(CLASSIFICATION.class);

    private final int value;

    CLASSIFICATION(int value) {
      this.value = value;
    }

    /**
     * Return the constant for {@code value} or null.
     */
    public static CLASSIFICATION fromValue(int value) {
      switch (value) {
        case 0: return BLUE;
        case 1: return WHITE;
        case 2: return YELLOW;
        case 3: return ORANGE;
        case 4: return RED;
        case 5: return NEUTRON;
        case 6: return BLACKHOLE;
        case 7: return MARKER;
        case 8: return WORMHOLE;
        default: return null;
      }
    }

    @Override
    public int getValue() {
      return value;
    }
  }

  /**
   * These are extra details stored with the star that define the properties needed by wormholes.
   */
  public static final class Wormhole extends Message<Wormhole, Wormhole.Builder> {
    public static final ProtoAdapter<Wormhole> ADAPTER = new ProtoAdapter_Wormhole();

    private static final long serialVersionUID = 0L;

    public static final Long DEFAULT_DEST_STAR_ID = 0L;

    public static final Long DEFAULT_TUNE_COMPLETE_TIME = 0L;

    public static final Long DEFAULT_EMPIRE_ID = 0L;

    @WireField(
        tag = 1,
        adapter = "com.squareup.wire.ProtoAdapter#INT64"
    )
    public final Long dest_star_id;

    @WireField(
        tag = 2,
        adapter = "com.squareup.wire.ProtoAdapter#INT64"
    )
    public final Long tune_complete_time;

    @WireField(
        tag = 3,
        adapter = "com.squareup.wire.ProtoAdapter#INT64",
        label = WireField.Label.REPEATED
    )
    public final List<Long> tune_history;

    @WireField(
        tag = 4,
        adapter = "com.squareup.wire.ProtoAdapter#INT64"
    )
    public final Long empire_id;

    public Wormhole(Long dest_star_id, Long tune_complete_time, List<Long> tune_history, Long empire_id) {
      this(dest_star_id, tune_complete_time, tune_history, empire_id, ByteString.EMPTY);
    }

    public Wormhole(Long dest_star_id, Long tune_complete_time, List<Long> tune_history, Long empire_id, ByteString unknownFields) {
      super(ADAPTER, unknownFields);
      this.dest_star_id = dest_star_id;
      this.tune_complete_time = tune_complete_time;
      this.tune_history = Internal.immutableCopyOf("tune_history", tune_history);
      this.empire_id = empire_id;
    }

    @Override
    public Builder newBuilder() {
      Builder builder = new Builder();
      builder.dest_star_id = dest_star_id;
      builder.tune_complete_time = tune_complete_time;
      builder.tune_history = Internal.copyOf("tune_history", tune_history);
      builder.empire_id = empire_id;
      builder.addUnknownFields(unknownFields());
      return builder;
    }

    @Override
    public boolean equals(Object other) {
      if (other == this) return true;
      if (!(other instanceof Wormhole)) return false;
      Wormhole o = (Wormhole) other;
      return Internal.equals(unknownFields(), o.unknownFields())
          && Internal.equals(dest_star_id, o.dest_star_id)
          && Internal.equals(tune_complete_time, o.tune_complete_time)
          && Internal.equals(tune_history, o.tune_history)
          && Internal.equals(empire_id, o.empire_id);
    }

    @Override
    public int hashCode() {
      int result = super.hashCode;
      if (result == 0) {
        result = unknownFields().hashCode();
        result = result * 37 + (dest_star_id != null ? dest_star_id.hashCode() : 0);
        result = result * 37 + (tune_complete_time != null ? tune_complete_time.hashCode() : 0);
        result = result * 37 + (tune_history != null ? tune_history.hashCode() : 1);
        result = result * 37 + (empire_id != null ? empire_id.hashCode() : 0);
        super.hashCode = result;
      }
      return result;
    }

    @Override
    public String toString() {
      StringBuilder builder = new StringBuilder();
      if (dest_star_id != null) builder.append(", dest_star_id=").append(dest_star_id);
      if (tune_complete_time != null) builder.append(", tune_complete_time=").append(tune_complete_time);
      if (tune_history != null) builder.append(", tune_history=").append(tune_history);
      if (empire_id != null) builder.append(", empire_id=").append(empire_id);
      return builder.replace(0, 2, "Wormhole{").append('}').toString();
    }

    public static final class Builder extends Message.Builder<Wormhole, Builder> {
      public Long dest_star_id;

      public Long tune_complete_time;

      public List<Long> tune_history;

      public Long empire_id;

      public Builder() {
        tune_history = Internal.newMutableList();
      }

      public Builder dest_star_id(Long dest_star_id) {
        this.dest_star_id = dest_star_id;
        return this;
      }

      public Builder tune_complete_time(Long tune_complete_time) {
        this.tune_complete_time = tune_complete_time;
        return this;
      }

      public Builder tune_history(List<Long> tune_history) {
        Internal.checkElementsNotNull(tune_history);
        this.tune_history = tune_history;
        return this;
      }

      public Builder empire_id(Long empire_id) {
        this.empire_id = empire_id;
        return this;
      }

      @Override
      public Wormhole build() {
        return new Wormhole(dest_star_id, tune_complete_time, tune_history, empire_id, buildUnknownFields());
      }
    }

    private static final class ProtoAdapter_Wormhole extends ProtoAdapter<Wormhole> {
      ProtoAdapter_Wormhole() {
        super(FieldEncoding.LENGTH_DELIMITED, Wormhole.class);
      }

      @Override
      public int encodedSize(Wormhole value) {
        return (value.dest_star_id != null ? ProtoAdapter.INT64.encodedSizeWithTag(1, value.dest_star_id) : 0)
            + (value.tune_complete_time != null ? ProtoAdapter.INT64.encodedSizeWithTag(2, value.tune_complete_time) : 0)
            + ProtoAdapter.INT64.asRepeated().encodedSizeWithTag(3, value.tune_history)
            + (value.empire_id != null ? ProtoAdapter.INT64.encodedSizeWithTag(4, value.empire_id) : 0)
            + value.unknownFields().size();
      }

      @Override
      public void encode(ProtoWriter writer, Wormhole value) throws IOException {
        if (value.dest_star_id != null) ProtoAdapter.INT64.encodeWithTag(writer, 1, value.dest_star_id);
        if (value.tune_complete_time != null) ProtoAdapter.INT64.encodeWithTag(writer, 2, value.tune_complete_time);
        if (value.tune_history != null) ProtoAdapter.INT64.asRepeated().encodeWithTag(writer, 3, value.tune_history);
        if (value.empire_id != null) ProtoAdapter.INT64.encodeWithTag(writer, 4, value.empire_id);
        writer.writeBytes(value.unknownFields());
      }

      @Override
      public Wormhole decode(ProtoReader reader) throws IOException {
        Builder builder = new Builder();
        long token = reader.beginMessage();
        for (int tag; (tag = reader.nextTag()) != -1;) {
          switch (tag) {
            case 1: builder.dest_star_id(ProtoAdapter.INT64.decode(reader)); break;
            case 2: builder.tune_complete_time(ProtoAdapter.INT64.decode(reader)); break;
            case 3: builder.tune_history.add(ProtoAdapter.INT64.decode(reader)); break;
            case 4: builder.empire_id(ProtoAdapter.INT64.decode(reader)); break;
            default: {
              FieldEncoding fieldEncoding = reader.peekFieldEncoding();
              Object value = fieldEncoding.rawProtoAdapter().decode(reader);
              builder.addUnknownField(tag, fieldEncoding, value);
            }
          }
        }
        reader.endMessage(token);
        return builder.build();
      }

      @Override
      public Wormhole redact(Wormhole value) {
        Builder builder = value.newBuilder();
        builder.clearUnknownFields();
        return builder.build();
      }
    }
  }

  private static final class ProtoAdapter_Star extends ProtoAdapter<Star> {
    ProtoAdapter_Star() {
      super(FieldEncoding.LENGTH_DELIMITED, Star.class);
    }

    @Override
    public int encodedSize(Star value) {
      return (value.key != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.key) : 0)
          + (value.sector_x != null ? ProtoAdapter.INT64.encodedSizeWithTag(11, value.sector_x) : 0)
          + (value.sector_y != null ? ProtoAdapter.INT64.encodedSizeWithTag(12, value.sector_y) : 0)
          + (value.name != null ? ProtoAdapter.STRING.encodedSizeWithTag(2, value.name) : 0)
          + (value.classification != null ? CLASSIFICATION.ADAPTER.encodedSizeWithTag(3, value.classification) : 0)
          + (value.size != null ? ProtoAdapter.INT32.encodedSizeWithTag(5, value.size) : 0)
          + (value.offset_x != null ? ProtoAdapter.INT32.encodedSizeWithTag(6, value.offset_x) : 0)
          + (value.offset_y != null ? ProtoAdapter.INT32.encodedSizeWithTag(7, value.offset_y) : 0)
          + Planet.ADAPTER.asRepeated().encodedSizeWithTag(9, value.planets)
          + (value.time_emptied != null ? ProtoAdapter.INT64.encodedSizeWithTag(17, value.time_emptied) : 0)
          + (value.last_simulation != null ? ProtoAdapter.INT64.encodedSizeWithTag(18, value.last_simulation) : 0)
          + (value.wormhole != null ? Wormhole.ADAPTER.encodedSizeWithTag(20, value.wormhole) : 0)
          + value.unknownFields().size();
    }

    @Override
    public void encode(ProtoWriter writer, Star value) throws IOException {
      if (value.key != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.key);
      if (value.sector_x != null) ProtoAdapter.INT64.encodeWithTag(writer, 11, value.sector_x);
      if (value.sector_y != null) ProtoAdapter.INT64.encodeWithTag(writer, 12, value.sector_y);
      if (value.name != null) ProtoAdapter.STRING.encodeWithTag(writer, 2, value.name);
      if (value.classification != null) CLASSIFICATION.ADAPTER.encodeWithTag(writer, 3, value.classification);
      if (value.size != null) ProtoAdapter.INT32.encodeWithTag(writer, 5, value.size);
      if (value.offset_x != null) ProtoAdapter.INT32.encodeWithTag(writer, 6, value.offset_x);
      if (value.offset_y != null) ProtoAdapter.INT32.encodeWithTag(writer, 7, value.offset_y);
      if (value.planets != null) Planet.ADAPTER.asRepeated().encodeWithTag(writer, 9, value.planets);
      if (value.time_emptied != null) ProtoAdapter.INT64.encodeWithTag(writer, 17, value.time_emptied);
      if (value.last_simulation != null) ProtoAdapter.INT64.encodeWithTag(writer, 18, value.last_simulation);
      if (value.wormhole != null) Wormhole.ADAPTER.encodeWithTag(writer, 20, value.wormhole);
      writer.writeBytes(value.unknownFields());
    }

    @Override
    public Star decode(ProtoReader reader) throws IOException {
      Builder builder = new Builder();
      long token = reader.beginMessage();
      for (int tag; (tag = reader.nextTag()) != -1;) {
        switch (tag) {
          case 1: builder.key(ProtoAdapter.STRING.decode(reader)); break;
          case 11: builder.sector_x(ProtoAdapter.INT64.decode(reader)); break;
          case 12: builder.sector_y(ProtoAdapter.INT64.decode(reader)); break;
          case 2: builder.name(ProtoAdapter.STRING.decode(reader)); break;
          case 3: {
            try {
              builder.classification(CLASSIFICATION.ADAPTER.decode(reader));
            } catch (ProtoAdapter.EnumConstantNotFoundException e) {
              builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
            }
            break;
          }
          case 5: builder.size(ProtoAdapter.INT32.decode(reader)); break;
          case 6: builder.offset_x(ProtoAdapter.INT32.decode(reader)); break;
          case 7: builder.offset_y(ProtoAdapter.INT32.decode(reader)); break;
          case 9: builder.planets.add(Planet.ADAPTER.decode(reader)); break;
          case 17: builder.time_emptied(ProtoAdapter.INT64.decode(reader)); break;
          case 18: builder.last_simulation(ProtoAdapter.INT64.decode(reader)); break;
          case 20: builder.wormhole(Wormhole.ADAPTER.decode(reader)); break;
          default: {
            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
            builder.addUnknownField(tag, fieldEncoding, value);
          }
        }
      }
      reader.endMessage(token);
      return builder.build();
    }

    @Override
    public Star redact(Star value) {
      Builder builder = value.newBuilder();
      Internal.redactElements(builder.planets, Planet.ADAPTER);
      if (builder.wormhole != null) builder.wormhole = Wormhole.ADAPTER.redact(builder.wormhole);
      builder.clearUnknownFields();
      return builder.build();
    }
  }
}
