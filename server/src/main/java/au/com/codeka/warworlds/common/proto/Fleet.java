// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: au/com/codeka/warworlds/common/proto/fleet.proto at 7:1
package au.com.codeka.warworlds.common.proto;

import com.squareup.wire.FieldEncoding;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoAdapter;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.ProtoWriter;
import com.squareup.wire.WireEnum;
import com.squareup.wire.WireField;
import com.squareup.wire.internal.Internal;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Float;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import okio.ByteString;

/**
 * A fleet represents one or more ships of the same(?) design.
 */
public final class Fleet extends Message<Fleet, Fleet.Builder> {
  public static final ProtoAdapter<Fleet> ADAPTER = new ProtoAdapter_Fleet();

  private static final long serialVersionUID = 0L;

  public static final Long DEFAULT_ID = 0L;

  public static final Long DEFAULT_EMPIRE_ID = 0L;

  public static final Long DEFAULT_ALLIANCE_ID = 0L;

  public static final Design.DesignType DEFAULT_DESIGN_TYPE = Design.DesignType.UNKNOWN_DESIGN;

  public static final Float DEFAULT_NUM_SHIPS = 0.0f;

  public static final FLEET_STATE DEFAULT_STATE = FLEET_STATE.IDLE;

  public static final Long DEFAULT_STATE_START_TIME = 0L;

  public static final Long DEFAULT_DESTINATION_STAR_ID = 0L;

  public static final Long DEFAULT_TARGET_FLEET_ID = 0L;

  public static final FLEET_STANCE DEFAULT_STANCE = FLEET_STANCE.PASSIVE;

  public static final Boolean DEFAULT_IS_DESTROYED = false;

  public static final Boolean DEFAULT_BLOCK_NOTIFICATION_ON_DESTROY = false;

  public static final Long DEFAULT_LAST_VICTORY = 0L;

  public static final Long DEFAULT_ETA = 0L;

  public static final String DEFAULT_NOTES = "";

  /**
   * ID of this fleet, so that it can be referred to by other entities.
   */
  @WireField(
      tag = 1,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long id;

  /**
   * The ID of the empire who owns this fleet
   */
  @WireField(
      tag = 2,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long empire_id;

  /**
   * The ID of the alliance this fleet belongs to. If not specified, it means the empire that owns
   * this fleet does not belong to an alliance.
   */
  @WireField(
      tag = 3,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long alliance_id;

  /**
   * The ID of the ship design of the ship(s) in this fleet
   */
  @WireField(
      tag = 4,
      adapter = "au.com.codeka.warworlds.common.proto.Design$DesignType#ADAPTER"
  )
  public final Design.DesignType design_type;

  /**
   * The number of ships in this fleet. This is a floating point number because of the way damage is
   * calculated in combat. We only ever display the Math.ceil() of this number to the user, however.
   */
  @WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#FLOAT"
  )
  public final Float num_ships;

  @WireField(
      tag = 6,
      adapter = "au.com.codeka.warworlds.common.proto.Fleet$FLEET_STATE#ADAPTER"
  )
  public final FLEET_STATE state;

  /**
   * The time this fleet was moved into the current state (used to determine things like
   * distance between planets when moving, etc)
   */
  @WireField(
      tag = 7,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long state_start_time;

  /**
   * If we're moving, this will be the ID of the star we're moving to.
   */
  @WireField(
      tag = 8,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long destination_star_id;

  /**
   * If in attacking state, this is the target fleet or colony we're attacking. Only makes sense if
   * the fleet is on the same star as the target.
   */
  @WireField(
      tag = 9,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long target_fleet_id;

  @WireField(
      tag = 10,
      adapter = "au.com.codeka.warworlds.common.proto.Fleet$FLEET_STANCE#ADAPTER"
  )
  public final FLEET_STANCE stance;

  /**
   * This is used internally by the server, it'll never appear in a response from the server.
   */
  @WireField(
      tag = 11,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL"
  )
  public final Boolean is_destroyed;

  @WireField(
      tag = 12,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL"
  )
  public final Boolean block_notification_on_destroy;

  /**
   * This is the date/time of the last battle this fleet was victorious in, it's mostly useless on
   * the client (used for some housekeeping on the server)
   */
  @WireField(
      tag = 13,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long last_victory;

  /**
   * for moving fleets, this is the time we expect it to arrive
   */
  @WireField(
      tag = 14,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long eta;

  /**
   * notes the player has attached so that he can remember what the fleet was for.
   */
  @WireField(
      tag = 15,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String notes;

  public Fleet(Long id, Long empire_id, Long alliance_id, Design.DesignType design_type, Float num_ships, FLEET_STATE state, Long state_start_time, Long destination_star_id, Long target_fleet_id, FLEET_STANCE stance, Boolean is_destroyed, Boolean block_notification_on_destroy, Long last_victory, Long eta, String notes) {
    this(id, empire_id, alliance_id, design_type, num_ships, state, state_start_time, destination_star_id, target_fleet_id, stance, is_destroyed, block_notification_on_destroy, last_victory, eta, notes, ByteString.EMPTY);
  }

  public Fleet(Long id, Long empire_id, Long alliance_id, Design.DesignType design_type, Float num_ships, FLEET_STATE state, Long state_start_time, Long destination_star_id, Long target_fleet_id, FLEET_STANCE stance, Boolean is_destroyed, Boolean block_notification_on_destroy, Long last_victory, Long eta, String notes, ByteString unknownFields) {
    super(ADAPTER, unknownFields);
    this.id = id;
    this.empire_id = empire_id;
    this.alliance_id = alliance_id;
    this.design_type = design_type;
    this.num_ships = num_ships;
    this.state = state;
    this.state_start_time = state_start_time;
    this.destination_star_id = destination_star_id;
    this.target_fleet_id = target_fleet_id;
    this.stance = stance;
    this.is_destroyed = is_destroyed;
    this.block_notification_on_destroy = block_notification_on_destroy;
    this.last_victory = last_victory;
    this.eta = eta;
    this.notes = notes;
  }

  @Override
  public Builder newBuilder() {
    Builder builder = new Builder();
    builder.id = id;
    builder.empire_id = empire_id;
    builder.alliance_id = alliance_id;
    builder.design_type = design_type;
    builder.num_ships = num_ships;
    builder.state = state;
    builder.state_start_time = state_start_time;
    builder.destination_star_id = destination_star_id;
    builder.target_fleet_id = target_fleet_id;
    builder.stance = stance;
    builder.is_destroyed = is_destroyed;
    builder.block_notification_on_destroy = block_notification_on_destroy;
    builder.last_victory = last_victory;
    builder.eta = eta;
    builder.notes = notes;
    builder.addUnknownFields(unknownFields());
    return builder;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof Fleet)) return false;
    Fleet o = (Fleet) other;
    return Internal.equals(unknownFields(), o.unknownFields())
        && Internal.equals(id, o.id)
        && Internal.equals(empire_id, o.empire_id)
        && Internal.equals(alliance_id, o.alliance_id)
        && Internal.equals(design_type, o.design_type)
        && Internal.equals(num_ships, o.num_ships)
        && Internal.equals(state, o.state)
        && Internal.equals(state_start_time, o.state_start_time)
        && Internal.equals(destination_star_id, o.destination_star_id)
        && Internal.equals(target_fleet_id, o.target_fleet_id)
        && Internal.equals(stance, o.stance)
        && Internal.equals(is_destroyed, o.is_destroyed)
        && Internal.equals(block_notification_on_destroy, o.block_notification_on_destroy)
        && Internal.equals(last_victory, o.last_victory)
        && Internal.equals(eta, o.eta)
        && Internal.equals(notes, o.notes);
  }

  @Override
  public int hashCode() {
    int result = super.hashCode;
    if (result == 0) {
      result = unknownFields().hashCode();
      result = result * 37 + (id != null ? id.hashCode() : 0);
      result = result * 37 + (empire_id != null ? empire_id.hashCode() : 0);
      result = result * 37 + (alliance_id != null ? alliance_id.hashCode() : 0);
      result = result * 37 + (design_type != null ? design_type.hashCode() : 0);
      result = result * 37 + (num_ships != null ? num_ships.hashCode() : 0);
      result = result * 37 + (state != null ? state.hashCode() : 0);
      result = result * 37 + (state_start_time != null ? state_start_time.hashCode() : 0);
      result = result * 37 + (destination_star_id != null ? destination_star_id.hashCode() : 0);
      result = result * 37 + (target_fleet_id != null ? target_fleet_id.hashCode() : 0);
      result = result * 37 + (stance != null ? stance.hashCode() : 0);
      result = result * 37 + (is_destroyed != null ? is_destroyed.hashCode() : 0);
      result = result * 37 + (block_notification_on_destroy != null ? block_notification_on_destroy.hashCode() : 0);
      result = result * 37 + (last_victory != null ? last_victory.hashCode() : 0);
      result = result * 37 + (eta != null ? eta.hashCode() : 0);
      result = result * 37 + (notes != null ? notes.hashCode() : 0);
      super.hashCode = result;
    }
    return result;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    if (id != null) builder.append(", id=").append(id);
    if (empire_id != null) builder.append(", empire_id=").append(empire_id);
    if (alliance_id != null) builder.append(", alliance_id=").append(alliance_id);
    if (design_type != null) builder.append(", design_type=").append(design_type);
    if (num_ships != null) builder.append(", num_ships=").append(num_ships);
    if (state != null) builder.append(", state=").append(state);
    if (state_start_time != null) builder.append(", state_start_time=").append(state_start_time);
    if (destination_star_id != null) builder.append(", destination_star_id=").append(destination_star_id);
    if (target_fleet_id != null) builder.append(", target_fleet_id=").append(target_fleet_id);
    if (stance != null) builder.append(", stance=").append(stance);
    if (is_destroyed != null) builder.append(", is_destroyed=").append(is_destroyed);
    if (block_notification_on_destroy != null) builder.append(", block_notification_on_destroy=").append(block_notification_on_destroy);
    if (last_victory != null) builder.append(", last_victory=").append(last_victory);
    if (eta != null) builder.append(", eta=").append(eta);
    if (notes != null) builder.append(", notes=").append(notes);
    return builder.replace(0, 2, "Fleet{").append('}').toString();
  }

  public static final class Builder extends Message.Builder<Fleet, Builder> {
    public Long id;

    public Long empire_id;

    public Long alliance_id;

    public Design.DesignType design_type;

    public Float num_ships;

    public FLEET_STATE state;

    public Long state_start_time;

    public Long destination_star_id;

    public Long target_fleet_id;

    public FLEET_STANCE stance;

    public Boolean is_destroyed;

    public Boolean block_notification_on_destroy;

    public Long last_victory;

    public Long eta;

    public String notes;

    public Builder() {
    }

    /**
     * ID of this fleet, so that it can be referred to by other entities.
     */
    public Builder id(Long id) {
      this.id = id;
      return this;
    }

    /**
     * The ID of the empire who owns this fleet
     */
    public Builder empire_id(Long empire_id) {
      this.empire_id = empire_id;
      return this;
    }

    /**
     * The ID of the alliance this fleet belongs to. If not specified, it means the empire that owns
     * this fleet does not belong to an alliance.
     */
    public Builder alliance_id(Long alliance_id) {
      this.alliance_id = alliance_id;
      return this;
    }

    /**
     * The ID of the ship design of the ship(s) in this fleet
     */
    public Builder design_type(Design.DesignType design_type) {
      this.design_type = design_type;
      return this;
    }

    /**
     * The number of ships in this fleet. This is a floating point number because of the way damage is
     * calculated in combat. We only ever display the Math.ceil() of this number to the user, however.
     */
    public Builder num_ships(Float num_ships) {
      this.num_ships = num_ships;
      return this;
    }

    public Builder state(FLEET_STATE state) {
      this.state = state;
      return this;
    }

    /**
     * The time this fleet was moved into the current state (used to determine things like
     * distance between planets when moving, etc)
     */
    public Builder state_start_time(Long state_start_time) {
      this.state_start_time = state_start_time;
      return this;
    }

    /**
     * If we're moving, this will be the ID of the star we're moving to.
     */
    public Builder destination_star_id(Long destination_star_id) {
      this.destination_star_id = destination_star_id;
      return this;
    }

    /**
     * If in attacking state, this is the target fleet or colony we're attacking. Only makes sense if
     * the fleet is on the same star as the target.
     */
    public Builder target_fleet_id(Long target_fleet_id) {
      this.target_fleet_id = target_fleet_id;
      return this;
    }

    public Builder stance(FLEET_STANCE stance) {
      this.stance = stance;
      return this;
    }

    /**
     * This is used internally by the server, it'll never appear in a response from the server.
     */
    public Builder is_destroyed(Boolean is_destroyed) {
      this.is_destroyed = is_destroyed;
      return this;
    }

    public Builder block_notification_on_destroy(Boolean block_notification_on_destroy) {
      this.block_notification_on_destroy = block_notification_on_destroy;
      return this;
    }

    /**
     * This is the date/time of the last battle this fleet was victorious in, it's mostly useless on
     * the client (used for some housekeeping on the server)
     */
    public Builder last_victory(Long last_victory) {
      this.last_victory = last_victory;
      return this;
    }

    /**
     * for moving fleets, this is the time we expect it to arrive
     */
    public Builder eta(Long eta) {
      this.eta = eta;
      return this;
    }

    /**
     * notes the player has attached so that he can remember what the fleet was for.
     */
    public Builder notes(String notes) {
      this.notes = notes;
      return this;
    }

    @Override
    public Fleet build() {
      return new Fleet(id, empire_id, alliance_id, design_type, num_ships, state, state_start_time, destination_star_id, target_fleet_id, stance, is_destroyed, block_notification_on_destroy, last_victory, eta, notes, buildUnknownFields());
    }
  }

  /**
   * The current state of the fleet: idle == orbiting a star, moving == moving between stars,
   * attacking == attacking an enemy fleet, colony, etc
   */
  public enum FLEET_STATE implements WireEnum {
    IDLE(1),

    MOVING(2),

    ATTACKING(3);

    public static final ProtoAdapter<FLEET_STATE> ADAPTER = ProtoAdapter.newEnumAdapter(FLEET_STATE.class);

    private final int value;

    FLEET_STATE(int value) {
      this.value = value;
    }

    /**
     * Return the constant for {@code value} or null.
     */
    public static FLEET_STATE fromValue(int value) {
      switch (value) {
        case 1: return IDLE;
        case 2: return MOVING;
        case 3: return ATTACKING;
        default: return null;
      }
    }

    @Override
    public int getValue() {
      return value;
    }
  }

  /**
   * The stance of the fleet is how we react when an enemy fleet comes into our
   * airspace: passive == ignore them (even if they attack first), neutral == attack
   * if they attack first, aggressive == attack no matter what
   */
  public enum FLEET_STANCE implements WireEnum {
    PASSIVE(1),

    NEUTRAL(2),

    AGGRESSIVE(3);

    public static final ProtoAdapter<FLEET_STANCE> ADAPTER = ProtoAdapter.newEnumAdapter(FLEET_STANCE.class);

    private final int value;

    FLEET_STANCE(int value) {
      this.value = value;
    }

    /**
     * Return the constant for {@code value} or null.
     */
    public static FLEET_STANCE fromValue(int value) {
      switch (value) {
        case 1: return PASSIVE;
        case 2: return NEUTRAL;
        case 3: return AGGRESSIVE;
        default: return null;
      }
    }

    @Override
    public int getValue() {
      return value;
    }
  }

  private static final class ProtoAdapter_Fleet extends ProtoAdapter<Fleet> {
    ProtoAdapter_Fleet() {
      super(FieldEncoding.LENGTH_DELIMITED, Fleet.class);
    }

    @Override
    public int encodedSize(Fleet value) {
      return (value.id != null ? ProtoAdapter.INT64.encodedSizeWithTag(1, value.id) : 0)
          + (value.empire_id != null ? ProtoAdapter.INT64.encodedSizeWithTag(2, value.empire_id) : 0)
          + (value.alliance_id != null ? ProtoAdapter.INT64.encodedSizeWithTag(3, value.alliance_id) : 0)
          + (value.design_type != null ? Design.DesignType.ADAPTER.encodedSizeWithTag(4, value.design_type) : 0)
          + (value.num_ships != null ? ProtoAdapter.FLOAT.encodedSizeWithTag(5, value.num_ships) : 0)
          + (value.state != null ? FLEET_STATE.ADAPTER.encodedSizeWithTag(6, value.state) : 0)
          + (value.state_start_time != null ? ProtoAdapter.INT64.encodedSizeWithTag(7, value.state_start_time) : 0)
          + (value.destination_star_id != null ? ProtoAdapter.INT64.encodedSizeWithTag(8, value.destination_star_id) : 0)
          + (value.target_fleet_id != null ? ProtoAdapter.INT64.encodedSizeWithTag(9, value.target_fleet_id) : 0)
          + (value.stance != null ? FLEET_STANCE.ADAPTER.encodedSizeWithTag(10, value.stance) : 0)
          + (value.is_destroyed != null ? ProtoAdapter.BOOL.encodedSizeWithTag(11, value.is_destroyed) : 0)
          + (value.block_notification_on_destroy != null ? ProtoAdapter.BOOL.encodedSizeWithTag(12, value.block_notification_on_destroy) : 0)
          + (value.last_victory != null ? ProtoAdapter.INT64.encodedSizeWithTag(13, value.last_victory) : 0)
          + (value.eta != null ? ProtoAdapter.INT64.encodedSizeWithTag(14, value.eta) : 0)
          + (value.notes != null ? ProtoAdapter.STRING.encodedSizeWithTag(15, value.notes) : 0)
          + value.unknownFields().size();
    }

    @Override
    public void encode(ProtoWriter writer, Fleet value) throws IOException {
      if (value.id != null) ProtoAdapter.INT64.encodeWithTag(writer, 1, value.id);
      if (value.empire_id != null) ProtoAdapter.INT64.encodeWithTag(writer, 2, value.empire_id);
      if (value.alliance_id != null) ProtoAdapter.INT64.encodeWithTag(writer, 3, value.alliance_id);
      if (value.design_type != null) Design.DesignType.ADAPTER.encodeWithTag(writer, 4, value.design_type);
      if (value.num_ships != null) ProtoAdapter.FLOAT.encodeWithTag(writer, 5, value.num_ships);
      if (value.state != null) FLEET_STATE.ADAPTER.encodeWithTag(writer, 6, value.state);
      if (value.state_start_time != null) ProtoAdapter.INT64.encodeWithTag(writer, 7, value.state_start_time);
      if (value.destination_star_id != null) ProtoAdapter.INT64.encodeWithTag(writer, 8, value.destination_star_id);
      if (value.target_fleet_id != null) ProtoAdapter.INT64.encodeWithTag(writer, 9, value.target_fleet_id);
      if (value.stance != null) FLEET_STANCE.ADAPTER.encodeWithTag(writer, 10, value.stance);
      if (value.is_destroyed != null) ProtoAdapter.BOOL.encodeWithTag(writer, 11, value.is_destroyed);
      if (value.block_notification_on_destroy != null) ProtoAdapter.BOOL.encodeWithTag(writer, 12, value.block_notification_on_destroy);
      if (value.last_victory != null) ProtoAdapter.INT64.encodeWithTag(writer, 13, value.last_victory);
      if (value.eta != null) ProtoAdapter.INT64.encodeWithTag(writer, 14, value.eta);
      if (value.notes != null) ProtoAdapter.STRING.encodeWithTag(writer, 15, value.notes);
      writer.writeBytes(value.unknownFields());
    }

    @Override
    public Fleet decode(ProtoReader reader) throws IOException {
      Builder builder = new Builder();
      long token = reader.beginMessage();
      for (int tag; (tag = reader.nextTag()) != -1;) {
        switch (tag) {
          case 1: builder.id(ProtoAdapter.INT64.decode(reader)); break;
          case 2: builder.empire_id(ProtoAdapter.INT64.decode(reader)); break;
          case 3: builder.alliance_id(ProtoAdapter.INT64.decode(reader)); break;
          case 4: {
            try {
              builder.design_type(Design.DesignType.ADAPTER.decode(reader));
            } catch (ProtoAdapter.EnumConstantNotFoundException e) {
              builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
            }
            break;
          }
          case 5: builder.num_ships(ProtoAdapter.FLOAT.decode(reader)); break;
          case 6: {
            try {
              builder.state(FLEET_STATE.ADAPTER.decode(reader));
            } catch (ProtoAdapter.EnumConstantNotFoundException e) {
              builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
            }
            break;
          }
          case 7: builder.state_start_time(ProtoAdapter.INT64.decode(reader)); break;
          case 8: builder.destination_star_id(ProtoAdapter.INT64.decode(reader)); break;
          case 9: builder.target_fleet_id(ProtoAdapter.INT64.decode(reader)); break;
          case 10: {
            try {
              builder.stance(FLEET_STANCE.ADAPTER.decode(reader));
            } catch (ProtoAdapter.EnumConstantNotFoundException e) {
              builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
            }
            break;
          }
          case 11: builder.is_destroyed(ProtoAdapter.BOOL.decode(reader)); break;
          case 12: builder.block_notification_on_destroy(ProtoAdapter.BOOL.decode(reader)); break;
          case 13: builder.last_victory(ProtoAdapter.INT64.decode(reader)); break;
          case 14: builder.eta(ProtoAdapter.INT64.decode(reader)); break;
          case 15: builder.notes(ProtoAdapter.STRING.decode(reader)); break;
          default: {
            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
            builder.addUnknownField(tag, fieldEncoding, value);
          }
        }
      }
      reader.endMessage(token);
      return builder.build();
    }

    @Override
    public Fleet redact(Fleet value) {
      Builder builder = value.newBuilder();
      builder.clearUnknownFields();
      return builder.build();
    }
  }
}
